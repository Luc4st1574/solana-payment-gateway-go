// Code generated by ent, DO NOT EDIT.

package users

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the users type in the database.
	Label = "users"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldWalletAddress holds the string denoting the wallet_address field in the database.
	FieldWalletAddress = "wallet_address"
	// FieldHasAccess holds the string denoting the has_access field in the database.
	FieldHasAccess = "has_access"
	// EdgeMatches holds the string denoting the matches edge name in mutations.
	EdgeMatches = "matches"
	// EdgeMatchResults holds the string denoting the match_results edge name in mutations.
	EdgeMatchResults = "match_results"
	// EdgePayments holds the string denoting the payments edge name in mutations.
	EdgePayments = "payments"
	// Table holds the table name of the users in the database.
	Table = "users"
	// MatchesTable is the table that holds the matches relation/edge.
	MatchesTable = "matches"
	// MatchesInverseTable is the table name for the Matches entity.
	// It exists in this package in order to avoid circular dependency with the "matches" package.
	MatchesInverseTable = "matches"
	// MatchesColumn is the table column denoting the matches relation/edge.
	MatchesColumn = "users_matches"
	// MatchResultsTable is the table that holds the match_results relation/edge.
	MatchResultsTable = "match_results"
	// MatchResultsInverseTable is the table name for the MatchResults entity.
	// It exists in this package in order to avoid circular dependency with the "matchresults" package.
	MatchResultsInverseTable = "match_results"
	// MatchResultsColumn is the table column denoting the match_results relation/edge.
	MatchResultsColumn = "users_match_results"
	// PaymentsTable is the table that holds the payments relation/edge.
	PaymentsTable = "payment_verifications"
	// PaymentsInverseTable is the table name for the PaymentVerifications entity.
	// It exists in this package in order to avoid circular dependency with the "paymentverifications" package.
	PaymentsInverseTable = "payment_verifications"
	// PaymentsColumn is the table column denoting the payments relation/edge.
	PaymentsColumn = "user_id"
)

// Columns holds all SQL columns for users fields.
var Columns = []string{
	FieldID,
	FieldWalletAddress,
	FieldHasAccess,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

var (
	// WalletAddressValidator is a validator for the "wallet_address" field. It is called by the builders before save.
	WalletAddressValidator func(string) error
	// DefaultHasAccess holds the default value on creation for the "has_access" field.
	DefaultHasAccess bool
)

// OrderOption defines the ordering options for the Users queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByWalletAddress orders the results by the wallet_address field.
func ByWalletAddress(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldWalletAddress, opts...).ToFunc()
}

// ByHasAccess orders the results by the has_access field.
func ByHasAccess(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldHasAccess, opts...).ToFunc()
}

// ByMatchesCount orders the results by matches count.
func ByMatchesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newMatchesStep(), opts...)
	}
}

// ByMatches orders the results by matches terms.
func ByMatches(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newMatchesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByMatchResultsCount orders the results by match_results count.
func ByMatchResultsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newMatchResultsStep(), opts...)
	}
}

// ByMatchResults orders the results by match_results terms.
func ByMatchResults(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newMatchResultsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByPaymentsCount orders the results by payments count.
func ByPaymentsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newPaymentsStep(), opts...)
	}
}

// ByPayments orders the results by payments terms.
func ByPayments(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newPaymentsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newMatchesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(MatchesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, MatchesTable, MatchesColumn),
	)
}
func newMatchResultsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(MatchResultsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, MatchResultsTable, MatchResultsColumn),
	)
}
func newPaymentsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(PaymentsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, PaymentsTable, PaymentsColumn),
	)
}
