// Code generated by ent, DO NOT EDIT.

package ent

import (
	"bitsnake-server/internal/ent/matches"
	"bitsnake-server/internal/ent/matchresults"
	"bitsnake-server/internal/ent/paymentverifications"
	"bitsnake-server/internal/ent/predicate"
	"bitsnake-server/internal/ent/users"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMatchResults         = "MatchResults"
	TypeMatches              = "Matches"
	TypePaymentVerifications = "PaymentVerifications"
	TypeUsers                = "Users"
)

// MatchResultsMutation represents an operation that mutates the MatchResults nodes in the graph.
type MatchResultsMutation struct {
	config
	op               Op
	typ              string
	id               *int
	kills            *int
	addkills         *int
	is_winner        *bool
	reward_amount    *float64
	addreward_amount *float64
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	match            *int
	clearedmatch     bool
	done             bool
	oldValue         func(context.Context) (*MatchResults, error)
	predicates       []predicate.MatchResults
}

var _ ent.Mutation = (*MatchResultsMutation)(nil)

// matchresultsOption allows management of the mutation configuration using functional options.
type matchresultsOption func(*MatchResultsMutation)

// newMatchResultsMutation creates new mutation for the MatchResults entity.
func newMatchResultsMutation(c config, op Op, opts ...matchresultsOption) *MatchResultsMutation {
	m := &MatchResultsMutation{
		config:        c,
		op:            op,
		typ:           TypeMatchResults,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMatchResultsID sets the ID field of the mutation.
func withMatchResultsID(id int) matchresultsOption {
	return func(m *MatchResultsMutation) {
		var (
			err   error
			once  sync.Once
			value *MatchResults
		)
		m.oldValue = func(ctx context.Context) (*MatchResults, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MatchResults.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMatchResults sets the old MatchResults of the mutation.
func withMatchResults(node *MatchResults) matchresultsOption {
	return func(m *MatchResultsMutation) {
		m.oldValue = func(context.Context) (*MatchResults, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MatchResultsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MatchResultsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MatchResultsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MatchResultsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MatchResults.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKills sets the "kills" field.
func (m *MatchResultsMutation) SetKills(i int) {
	m.kills = &i
	m.addkills = nil
}

// Kills returns the value of the "kills" field in the mutation.
func (m *MatchResultsMutation) Kills() (r int, exists bool) {
	v := m.kills
	if v == nil {
		return
	}
	return *v, true
}

// OldKills returns the old "kills" field's value of the MatchResults entity.
// If the MatchResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchResultsMutation) OldKills(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKills: %w", err)
	}
	return oldValue.Kills, nil
}

// AddKills adds i to the "kills" field.
func (m *MatchResultsMutation) AddKills(i int) {
	if m.addkills != nil {
		*m.addkills += i
	} else {
		m.addkills = &i
	}
}

// AddedKills returns the value that was added to the "kills" field in this mutation.
func (m *MatchResultsMutation) AddedKills() (r int, exists bool) {
	v := m.addkills
	if v == nil {
		return
	}
	return *v, true
}

// ResetKills resets all changes to the "kills" field.
func (m *MatchResultsMutation) ResetKills() {
	m.kills = nil
	m.addkills = nil
}

// SetIsWinner sets the "is_winner" field.
func (m *MatchResultsMutation) SetIsWinner(b bool) {
	m.is_winner = &b
}

// IsWinner returns the value of the "is_winner" field in the mutation.
func (m *MatchResultsMutation) IsWinner() (r bool, exists bool) {
	v := m.is_winner
	if v == nil {
		return
	}
	return *v, true
}

// OldIsWinner returns the old "is_winner" field's value of the MatchResults entity.
// If the MatchResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchResultsMutation) OldIsWinner(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsWinner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsWinner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsWinner: %w", err)
	}
	return oldValue.IsWinner, nil
}

// ResetIsWinner resets all changes to the "is_winner" field.
func (m *MatchResultsMutation) ResetIsWinner() {
	m.is_winner = nil
}

// SetRewardAmount sets the "reward_amount" field.
func (m *MatchResultsMutation) SetRewardAmount(f float64) {
	m.reward_amount = &f
	m.addreward_amount = nil
}

// RewardAmount returns the value of the "reward_amount" field in the mutation.
func (m *MatchResultsMutation) RewardAmount() (r float64, exists bool) {
	v := m.reward_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardAmount returns the old "reward_amount" field's value of the MatchResults entity.
// If the MatchResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchResultsMutation) OldRewardAmount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardAmount: %w", err)
	}
	return oldValue.RewardAmount, nil
}

// AddRewardAmount adds f to the "reward_amount" field.
func (m *MatchResultsMutation) AddRewardAmount(f float64) {
	if m.addreward_amount != nil {
		*m.addreward_amount += f
	} else {
		m.addreward_amount = &f
	}
}

// AddedRewardAmount returns the value that was added to the "reward_amount" field in this mutation.
func (m *MatchResultsMutation) AddedRewardAmount() (r float64, exists bool) {
	v := m.addreward_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearRewardAmount clears the value of the "reward_amount" field.
func (m *MatchResultsMutation) ClearRewardAmount() {
	m.reward_amount = nil
	m.addreward_amount = nil
	m.clearedFields[matchresults.FieldRewardAmount] = struct{}{}
}

// RewardAmountCleared returns if the "reward_amount" field was cleared in this mutation.
func (m *MatchResultsMutation) RewardAmountCleared() bool {
	_, ok := m.clearedFields[matchresults.FieldRewardAmount]
	return ok
}

// ResetRewardAmount resets all changes to the "reward_amount" field.
func (m *MatchResultsMutation) ResetRewardAmount() {
	m.reward_amount = nil
	m.addreward_amount = nil
	delete(m.clearedFields, matchresults.FieldRewardAmount)
}

// SetUserID sets the "user" edge to the Users entity by id.
func (m *MatchResultsMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the Users entity.
func (m *MatchResultsMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the Users entity was cleared.
func (m *MatchResultsMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *MatchResultsMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MatchResultsMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MatchResultsMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetMatchID sets the "match" edge to the Matches entity by id.
func (m *MatchResultsMutation) SetMatchID(id int) {
	m.match = &id
}

// ClearMatch clears the "match" edge to the Matches entity.
func (m *MatchResultsMutation) ClearMatch() {
	m.clearedmatch = true
}

// MatchCleared reports if the "match" edge to the Matches entity was cleared.
func (m *MatchResultsMutation) MatchCleared() bool {
	return m.clearedmatch
}

// MatchID returns the "match" edge ID in the mutation.
func (m *MatchResultsMutation) MatchID() (id int, exists bool) {
	if m.match != nil {
		return *m.match, true
	}
	return
}

// MatchIDs returns the "match" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MatchID instead. It exists only for internal usage by the builders.
func (m *MatchResultsMutation) MatchIDs() (ids []int) {
	if id := m.match; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMatch resets all changes to the "match" edge.
func (m *MatchResultsMutation) ResetMatch() {
	m.match = nil
	m.clearedmatch = false
}

// Where appends a list predicates to the MatchResultsMutation builder.
func (m *MatchResultsMutation) Where(ps ...predicate.MatchResults) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MatchResultsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MatchResultsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MatchResults, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MatchResultsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MatchResultsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MatchResults).
func (m *MatchResultsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MatchResultsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.kills != nil {
		fields = append(fields, matchresults.FieldKills)
	}
	if m.is_winner != nil {
		fields = append(fields, matchresults.FieldIsWinner)
	}
	if m.reward_amount != nil {
		fields = append(fields, matchresults.FieldRewardAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MatchResultsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case matchresults.FieldKills:
		return m.Kills()
	case matchresults.FieldIsWinner:
		return m.IsWinner()
	case matchresults.FieldRewardAmount:
		return m.RewardAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MatchResultsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case matchresults.FieldKills:
		return m.OldKills(ctx)
	case matchresults.FieldIsWinner:
		return m.OldIsWinner(ctx)
	case matchresults.FieldRewardAmount:
		return m.OldRewardAmount(ctx)
	}
	return nil, fmt.Errorf("unknown MatchResults field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchResultsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case matchresults.FieldKills:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKills(v)
		return nil
	case matchresults.FieldIsWinner:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsWinner(v)
		return nil
	case matchresults.FieldRewardAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardAmount(v)
		return nil
	}
	return fmt.Errorf("unknown MatchResults field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MatchResultsMutation) AddedFields() []string {
	var fields []string
	if m.addkills != nil {
		fields = append(fields, matchresults.FieldKills)
	}
	if m.addreward_amount != nil {
		fields = append(fields, matchresults.FieldRewardAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MatchResultsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case matchresults.FieldKills:
		return m.AddedKills()
	case matchresults.FieldRewardAmount:
		return m.AddedRewardAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchResultsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case matchresults.FieldKills:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKills(v)
		return nil
	case matchresults.FieldRewardAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRewardAmount(v)
		return nil
	}
	return fmt.Errorf("unknown MatchResults numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MatchResultsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(matchresults.FieldRewardAmount) {
		fields = append(fields, matchresults.FieldRewardAmount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MatchResultsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MatchResultsMutation) ClearField(name string) error {
	switch name {
	case matchresults.FieldRewardAmount:
		m.ClearRewardAmount()
		return nil
	}
	return fmt.Errorf("unknown MatchResults nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MatchResultsMutation) ResetField(name string) error {
	switch name {
	case matchresults.FieldKills:
		m.ResetKills()
		return nil
	case matchresults.FieldIsWinner:
		m.ResetIsWinner()
		return nil
	case matchresults.FieldRewardAmount:
		m.ResetRewardAmount()
		return nil
	}
	return fmt.Errorf("unknown MatchResults field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MatchResultsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, matchresults.EdgeUser)
	}
	if m.match != nil {
		edges = append(edges, matchresults.EdgeMatch)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MatchResultsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case matchresults.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case matchresults.EdgeMatch:
		if id := m.match; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MatchResultsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MatchResultsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MatchResultsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, matchresults.EdgeUser)
	}
	if m.clearedmatch {
		edges = append(edges, matchresults.EdgeMatch)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MatchResultsMutation) EdgeCleared(name string) bool {
	switch name {
	case matchresults.EdgeUser:
		return m.cleareduser
	case matchresults.EdgeMatch:
		return m.clearedmatch
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MatchResultsMutation) ClearEdge(name string) error {
	switch name {
	case matchresults.EdgeUser:
		m.ClearUser()
		return nil
	case matchresults.EdgeMatch:
		m.ClearMatch()
		return nil
	}
	return fmt.Errorf("unknown MatchResults unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MatchResultsMutation) ResetEdge(name string) error {
	switch name {
	case matchresults.EdgeUser:
		m.ResetUser()
		return nil
	case matchresults.EdgeMatch:
		m.ResetMatch()
		return nil
	}
	return fmt.Errorf("unknown MatchResults edge %s", name)
}

// MatchesMutation represents an operation that mutates the Matches nodes in the graph.
type MatchesMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	game_hash_id         *string
	expiration_date      *time.Time
	wallet_address       *string
	transaction_hash     *string
	created_at           *time.Time
	clearedFields        map[string]struct{}
	match_results        map[int]struct{}
	removedmatch_results map[int]struct{}
	clearedmatch_results bool
	user                 *int
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*Matches, error)
	predicates           []predicate.Matches
}

var _ ent.Mutation = (*MatchesMutation)(nil)

// matchesOption allows management of the mutation configuration using functional options.
type matchesOption func(*MatchesMutation)

// newMatchesMutation creates new mutation for the Matches entity.
func newMatchesMutation(c config, op Op, opts ...matchesOption) *MatchesMutation {
	m := &MatchesMutation{
		config:        c,
		op:            op,
		typ:           TypeMatches,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMatchesID sets the ID field of the mutation.
func withMatchesID(id int) matchesOption {
	return func(m *MatchesMutation) {
		var (
			err   error
			once  sync.Once
			value *Matches
		)
		m.oldValue = func(ctx context.Context) (*Matches, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Matches.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMatches sets the old Matches of the mutation.
func withMatches(node *Matches) matchesOption {
	return func(m *MatchesMutation) {
		m.oldValue = func(context.Context) (*Matches, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MatchesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MatchesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MatchesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MatchesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Matches.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGameHashID sets the "game_hash_id" field.
func (m *MatchesMutation) SetGameHashID(s string) {
	m.game_hash_id = &s
}

// GameHashID returns the value of the "game_hash_id" field in the mutation.
func (m *MatchesMutation) GameHashID() (r string, exists bool) {
	v := m.game_hash_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGameHashID returns the old "game_hash_id" field's value of the Matches entity.
// If the Matches object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchesMutation) OldGameHashID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGameHashID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGameHashID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGameHashID: %w", err)
	}
	return oldValue.GameHashID, nil
}

// ResetGameHashID resets all changes to the "game_hash_id" field.
func (m *MatchesMutation) ResetGameHashID() {
	m.game_hash_id = nil
}

// SetExpirationDate sets the "expiration_date" field.
func (m *MatchesMutation) SetExpirationDate(t time.Time) {
	m.expiration_date = &t
}

// ExpirationDate returns the value of the "expiration_date" field in the mutation.
func (m *MatchesMutation) ExpirationDate() (r time.Time, exists bool) {
	v := m.expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpirationDate returns the old "expiration_date" field's value of the Matches entity.
// If the Matches object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchesMutation) OldExpirationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpirationDate: %w", err)
	}
	return oldValue.ExpirationDate, nil
}

// ClearExpirationDate clears the value of the "expiration_date" field.
func (m *MatchesMutation) ClearExpirationDate() {
	m.expiration_date = nil
	m.clearedFields[matches.FieldExpirationDate] = struct{}{}
}

// ExpirationDateCleared returns if the "expiration_date" field was cleared in this mutation.
func (m *MatchesMutation) ExpirationDateCleared() bool {
	_, ok := m.clearedFields[matches.FieldExpirationDate]
	return ok
}

// ResetExpirationDate resets all changes to the "expiration_date" field.
func (m *MatchesMutation) ResetExpirationDate() {
	m.expiration_date = nil
	delete(m.clearedFields, matches.FieldExpirationDate)
}

// SetWalletAddress sets the "wallet_address" field.
func (m *MatchesMutation) SetWalletAddress(s string) {
	m.wallet_address = &s
}

// WalletAddress returns the value of the "wallet_address" field in the mutation.
func (m *MatchesMutation) WalletAddress() (r string, exists bool) {
	v := m.wallet_address
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletAddress returns the old "wallet_address" field's value of the Matches entity.
// If the Matches object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchesMutation) OldWalletAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWalletAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWalletAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletAddress: %w", err)
	}
	return oldValue.WalletAddress, nil
}

// ResetWalletAddress resets all changes to the "wallet_address" field.
func (m *MatchesMutation) ResetWalletAddress() {
	m.wallet_address = nil
}

// SetTransactionHash sets the "transaction_hash" field.
func (m *MatchesMutation) SetTransactionHash(s string) {
	m.transaction_hash = &s
}

// TransactionHash returns the value of the "transaction_hash" field in the mutation.
func (m *MatchesMutation) TransactionHash() (r string, exists bool) {
	v := m.transaction_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionHash returns the old "transaction_hash" field's value of the Matches entity.
// If the Matches object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchesMutation) OldTransactionHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionHash: %w", err)
	}
	return oldValue.TransactionHash, nil
}

// ResetTransactionHash resets all changes to the "transaction_hash" field.
func (m *MatchesMutation) ResetTransactionHash() {
	m.transaction_hash = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MatchesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MatchesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Matches entity.
// If the Matches object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MatchesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddMatchResultIDs adds the "match_results" edge to the MatchResults entity by ids.
func (m *MatchesMutation) AddMatchResultIDs(ids ...int) {
	if m.match_results == nil {
		m.match_results = make(map[int]struct{})
	}
	for i := range ids {
		m.match_results[ids[i]] = struct{}{}
	}
}

// ClearMatchResults clears the "match_results" edge to the MatchResults entity.
func (m *MatchesMutation) ClearMatchResults() {
	m.clearedmatch_results = true
}

// MatchResultsCleared reports if the "match_results" edge to the MatchResults entity was cleared.
func (m *MatchesMutation) MatchResultsCleared() bool {
	return m.clearedmatch_results
}

// RemoveMatchResultIDs removes the "match_results" edge to the MatchResults entity by IDs.
func (m *MatchesMutation) RemoveMatchResultIDs(ids ...int) {
	if m.removedmatch_results == nil {
		m.removedmatch_results = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.match_results, ids[i])
		m.removedmatch_results[ids[i]] = struct{}{}
	}
}

// RemovedMatchResults returns the removed IDs of the "match_results" edge to the MatchResults entity.
func (m *MatchesMutation) RemovedMatchResultsIDs() (ids []int) {
	for id := range m.removedmatch_results {
		ids = append(ids, id)
	}
	return
}

// MatchResultsIDs returns the "match_results" edge IDs in the mutation.
func (m *MatchesMutation) MatchResultsIDs() (ids []int) {
	for id := range m.match_results {
		ids = append(ids, id)
	}
	return
}

// ResetMatchResults resets all changes to the "match_results" edge.
func (m *MatchesMutation) ResetMatchResults() {
	m.match_results = nil
	m.clearedmatch_results = false
	m.removedmatch_results = nil
}

// SetUserID sets the "user" edge to the Users entity by id.
func (m *MatchesMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the Users entity.
func (m *MatchesMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the Users entity was cleared.
func (m *MatchesMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *MatchesMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MatchesMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MatchesMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the MatchesMutation builder.
func (m *MatchesMutation) Where(ps ...predicate.Matches) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MatchesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MatchesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Matches, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MatchesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MatchesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Matches).
func (m *MatchesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MatchesMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.game_hash_id != nil {
		fields = append(fields, matches.FieldGameHashID)
	}
	if m.expiration_date != nil {
		fields = append(fields, matches.FieldExpirationDate)
	}
	if m.wallet_address != nil {
		fields = append(fields, matches.FieldWalletAddress)
	}
	if m.transaction_hash != nil {
		fields = append(fields, matches.FieldTransactionHash)
	}
	if m.created_at != nil {
		fields = append(fields, matches.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MatchesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case matches.FieldGameHashID:
		return m.GameHashID()
	case matches.FieldExpirationDate:
		return m.ExpirationDate()
	case matches.FieldWalletAddress:
		return m.WalletAddress()
	case matches.FieldTransactionHash:
		return m.TransactionHash()
	case matches.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MatchesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case matches.FieldGameHashID:
		return m.OldGameHashID(ctx)
	case matches.FieldExpirationDate:
		return m.OldExpirationDate(ctx)
	case matches.FieldWalletAddress:
		return m.OldWalletAddress(ctx)
	case matches.FieldTransactionHash:
		return m.OldTransactionHash(ctx)
	case matches.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Matches field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case matches.FieldGameHashID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGameHashID(v)
		return nil
	case matches.FieldExpirationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpirationDate(v)
		return nil
	case matches.FieldWalletAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletAddress(v)
		return nil
	case matches.FieldTransactionHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionHash(v)
		return nil
	case matches.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Matches field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MatchesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MatchesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Matches numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MatchesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(matches.FieldExpirationDate) {
		fields = append(fields, matches.FieldExpirationDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MatchesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MatchesMutation) ClearField(name string) error {
	switch name {
	case matches.FieldExpirationDate:
		m.ClearExpirationDate()
		return nil
	}
	return fmt.Errorf("unknown Matches nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MatchesMutation) ResetField(name string) error {
	switch name {
	case matches.FieldGameHashID:
		m.ResetGameHashID()
		return nil
	case matches.FieldExpirationDate:
		m.ResetExpirationDate()
		return nil
	case matches.FieldWalletAddress:
		m.ResetWalletAddress()
		return nil
	case matches.FieldTransactionHash:
		m.ResetTransactionHash()
		return nil
	case matches.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Matches field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MatchesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.match_results != nil {
		edges = append(edges, matches.EdgeMatchResults)
	}
	if m.user != nil {
		edges = append(edges, matches.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MatchesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case matches.EdgeMatchResults:
		ids := make([]ent.Value, 0, len(m.match_results))
		for id := range m.match_results {
			ids = append(ids, id)
		}
		return ids
	case matches.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MatchesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmatch_results != nil {
		edges = append(edges, matches.EdgeMatchResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MatchesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case matches.EdgeMatchResults:
		ids := make([]ent.Value, 0, len(m.removedmatch_results))
		for id := range m.removedmatch_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MatchesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmatch_results {
		edges = append(edges, matches.EdgeMatchResults)
	}
	if m.cleareduser {
		edges = append(edges, matches.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MatchesMutation) EdgeCleared(name string) bool {
	switch name {
	case matches.EdgeMatchResults:
		return m.clearedmatch_results
	case matches.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MatchesMutation) ClearEdge(name string) error {
	switch name {
	case matches.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Matches unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MatchesMutation) ResetEdge(name string) error {
	switch name {
	case matches.EdgeMatchResults:
		m.ResetMatchResults()
		return nil
	case matches.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Matches edge %s", name)
}

// PaymentVerificationsMutation represents an operation that mutates the PaymentVerifications nodes in the graph.
type PaymentVerificationsMutation struct {
	config
	op               Op
	typ              string
	id               *int
	wallet_address   *string
	amount           *float64
	addamount        *float64
	transaction_hash *string
	status           *paymentverifications.Status
	access_granted   *bool
	created_at       *time.Time
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*PaymentVerifications, error)
	predicates       []predicate.PaymentVerifications
}

var _ ent.Mutation = (*PaymentVerificationsMutation)(nil)

// paymentverificationsOption allows management of the mutation configuration using functional options.
type paymentverificationsOption func(*PaymentVerificationsMutation)

// newPaymentVerificationsMutation creates new mutation for the PaymentVerifications entity.
func newPaymentVerificationsMutation(c config, op Op, opts ...paymentverificationsOption) *PaymentVerificationsMutation {
	m := &PaymentVerificationsMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentVerifications,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentVerificationsID sets the ID field of the mutation.
func withPaymentVerificationsID(id int) paymentverificationsOption {
	return func(m *PaymentVerificationsMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentVerifications
		)
		m.oldValue = func(ctx context.Context) (*PaymentVerifications, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentVerifications.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentVerifications sets the old PaymentVerifications of the mutation.
func withPaymentVerifications(node *PaymentVerifications) paymentverificationsOption {
	return func(m *PaymentVerificationsMutation) {
		m.oldValue = func(context.Context) (*PaymentVerifications, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentVerificationsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentVerificationsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentVerificationsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentVerificationsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentVerifications.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *PaymentVerificationsMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PaymentVerificationsMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PaymentVerifications entity.
// If the PaymentVerifications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentVerificationsMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PaymentVerificationsMutation) ResetUserID() {
	m.user = nil
}

// SetWalletAddress sets the "wallet_address" field.
func (m *PaymentVerificationsMutation) SetWalletAddress(s string) {
	m.wallet_address = &s
}

// WalletAddress returns the value of the "wallet_address" field in the mutation.
func (m *PaymentVerificationsMutation) WalletAddress() (r string, exists bool) {
	v := m.wallet_address
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletAddress returns the old "wallet_address" field's value of the PaymentVerifications entity.
// If the PaymentVerifications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentVerificationsMutation) OldWalletAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWalletAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWalletAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletAddress: %w", err)
	}
	return oldValue.WalletAddress, nil
}

// ResetWalletAddress resets all changes to the "wallet_address" field.
func (m *PaymentVerificationsMutation) ResetWalletAddress() {
	m.wallet_address = nil
}

// SetAmount sets the "amount" field.
func (m *PaymentVerificationsMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentVerificationsMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the PaymentVerifications entity.
// If the PaymentVerifications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentVerificationsMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *PaymentVerificationsMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentVerificationsMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentVerificationsMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetTransactionHash sets the "transaction_hash" field.
func (m *PaymentVerificationsMutation) SetTransactionHash(s string) {
	m.transaction_hash = &s
}

// TransactionHash returns the value of the "transaction_hash" field in the mutation.
func (m *PaymentVerificationsMutation) TransactionHash() (r string, exists bool) {
	v := m.transaction_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionHash returns the old "transaction_hash" field's value of the PaymentVerifications entity.
// If the PaymentVerifications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentVerificationsMutation) OldTransactionHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionHash: %w", err)
	}
	return oldValue.TransactionHash, nil
}

// ClearTransactionHash clears the value of the "transaction_hash" field.
func (m *PaymentVerificationsMutation) ClearTransactionHash() {
	m.transaction_hash = nil
	m.clearedFields[paymentverifications.FieldTransactionHash] = struct{}{}
}

// TransactionHashCleared returns if the "transaction_hash" field was cleared in this mutation.
func (m *PaymentVerificationsMutation) TransactionHashCleared() bool {
	_, ok := m.clearedFields[paymentverifications.FieldTransactionHash]
	return ok
}

// ResetTransactionHash resets all changes to the "transaction_hash" field.
func (m *PaymentVerificationsMutation) ResetTransactionHash() {
	m.transaction_hash = nil
	delete(m.clearedFields, paymentverifications.FieldTransactionHash)
}

// SetStatus sets the "status" field.
func (m *PaymentVerificationsMutation) SetStatus(pa paymentverifications.Status) {
	m.status = &pa
}

// Status returns the value of the "status" field in the mutation.
func (m *PaymentVerificationsMutation) Status() (r paymentverifications.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PaymentVerifications entity.
// If the PaymentVerifications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentVerificationsMutation) OldStatus(ctx context.Context) (v paymentverifications.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PaymentVerificationsMutation) ResetStatus() {
	m.status = nil
}

// SetAccessGranted sets the "access_granted" field.
func (m *PaymentVerificationsMutation) SetAccessGranted(b bool) {
	m.access_granted = &b
}

// AccessGranted returns the value of the "access_granted" field in the mutation.
func (m *PaymentVerificationsMutation) AccessGranted() (r bool, exists bool) {
	v := m.access_granted
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessGranted returns the old "access_granted" field's value of the PaymentVerifications entity.
// If the PaymentVerifications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentVerificationsMutation) OldAccessGranted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessGranted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessGranted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessGranted: %w", err)
	}
	return oldValue.AccessGranted, nil
}

// ResetAccessGranted resets all changes to the "access_granted" field.
func (m *PaymentVerificationsMutation) ResetAccessGranted() {
	m.access_granted = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentVerificationsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentVerificationsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentVerifications entity.
// If the PaymentVerifications object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentVerificationsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentVerificationsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the Users entity.
func (m *PaymentVerificationsMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[paymentverifications.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the Users entity was cleared.
func (m *PaymentVerificationsMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PaymentVerificationsMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PaymentVerificationsMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PaymentVerificationsMutation builder.
func (m *PaymentVerificationsMutation) Where(ps ...predicate.PaymentVerifications) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentVerificationsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentVerificationsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentVerifications, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentVerificationsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentVerificationsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentVerifications).
func (m *PaymentVerificationsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentVerificationsMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user != nil {
		fields = append(fields, paymentverifications.FieldUserID)
	}
	if m.wallet_address != nil {
		fields = append(fields, paymentverifications.FieldWalletAddress)
	}
	if m.amount != nil {
		fields = append(fields, paymentverifications.FieldAmount)
	}
	if m.transaction_hash != nil {
		fields = append(fields, paymentverifications.FieldTransactionHash)
	}
	if m.status != nil {
		fields = append(fields, paymentverifications.FieldStatus)
	}
	if m.access_granted != nil {
		fields = append(fields, paymentverifications.FieldAccessGranted)
	}
	if m.created_at != nil {
		fields = append(fields, paymentverifications.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentVerificationsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentverifications.FieldUserID:
		return m.UserID()
	case paymentverifications.FieldWalletAddress:
		return m.WalletAddress()
	case paymentverifications.FieldAmount:
		return m.Amount()
	case paymentverifications.FieldTransactionHash:
		return m.TransactionHash()
	case paymentverifications.FieldStatus:
		return m.Status()
	case paymentverifications.FieldAccessGranted:
		return m.AccessGranted()
	case paymentverifications.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentVerificationsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentverifications.FieldUserID:
		return m.OldUserID(ctx)
	case paymentverifications.FieldWalletAddress:
		return m.OldWalletAddress(ctx)
	case paymentverifications.FieldAmount:
		return m.OldAmount(ctx)
	case paymentverifications.FieldTransactionHash:
		return m.OldTransactionHash(ctx)
	case paymentverifications.FieldStatus:
		return m.OldStatus(ctx)
	case paymentverifications.FieldAccessGranted:
		return m.OldAccessGranted(ctx)
	case paymentverifications.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentVerifications field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentVerificationsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentverifications.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case paymentverifications.FieldWalletAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletAddress(v)
		return nil
	case paymentverifications.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case paymentverifications.FieldTransactionHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionHash(v)
		return nil
	case paymentverifications.FieldStatus:
		v, ok := value.(paymentverifications.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case paymentverifications.FieldAccessGranted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessGranted(v)
		return nil
	case paymentverifications.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentVerifications field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentVerificationsMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, paymentverifications.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentVerificationsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymentverifications.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentVerificationsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymentverifications.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentVerifications numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentVerificationsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymentverifications.FieldTransactionHash) {
		fields = append(fields, paymentverifications.FieldTransactionHash)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentVerificationsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentVerificationsMutation) ClearField(name string) error {
	switch name {
	case paymentverifications.FieldTransactionHash:
		m.ClearTransactionHash()
		return nil
	}
	return fmt.Errorf("unknown PaymentVerifications nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentVerificationsMutation) ResetField(name string) error {
	switch name {
	case paymentverifications.FieldUserID:
		m.ResetUserID()
		return nil
	case paymentverifications.FieldWalletAddress:
		m.ResetWalletAddress()
		return nil
	case paymentverifications.FieldAmount:
		m.ResetAmount()
		return nil
	case paymentverifications.FieldTransactionHash:
		m.ResetTransactionHash()
		return nil
	case paymentverifications.FieldStatus:
		m.ResetStatus()
		return nil
	case paymentverifications.FieldAccessGranted:
		m.ResetAccessGranted()
		return nil
	case paymentverifications.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PaymentVerifications field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentVerificationsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, paymentverifications.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentVerificationsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymentverifications.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentVerificationsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentVerificationsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentVerificationsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, paymentverifications.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentVerificationsMutation) EdgeCleared(name string) bool {
	switch name {
	case paymentverifications.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentVerificationsMutation) ClearEdge(name string) error {
	switch name {
	case paymentverifications.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PaymentVerifications unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentVerificationsMutation) ResetEdge(name string) error {
	switch name {
	case paymentverifications.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PaymentVerifications edge %s", name)
}

// UsersMutation represents an operation that mutates the Users nodes in the graph.
type UsersMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	wallet_address       *string
	has_access           *bool
	clearedFields        map[string]struct{}
	matches              map[int]struct{}
	removedmatches       map[int]struct{}
	clearedmatches       bool
	match_results        map[int]struct{}
	removedmatch_results map[int]struct{}
	clearedmatch_results bool
	payments             map[int]struct{}
	removedpayments      map[int]struct{}
	clearedpayments      bool
	done                 bool
	oldValue             func(context.Context) (*Users, error)
	predicates           []predicate.Users
}

var _ ent.Mutation = (*UsersMutation)(nil)

// usersOption allows management of the mutation configuration using functional options.
type usersOption func(*UsersMutation)

// newUsersMutation creates new mutation for the Users entity.
func newUsersMutation(c config, op Op, opts ...usersOption) *UsersMutation {
	m := &UsersMutation{
		config:        c,
		op:            op,
		typ:           TypeUsers,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsersID sets the ID field of the mutation.
func withUsersID(id int) usersOption {
	return func(m *UsersMutation) {
		var (
			err   error
			once  sync.Once
			value *Users
		)
		m.oldValue = func(ctx context.Context) (*Users, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Users.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsers sets the old Users of the mutation.
func withUsers(node *Users) usersOption {
	return func(m *UsersMutation) {
		m.oldValue = func(context.Context) (*Users, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsersMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsersMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Users.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWalletAddress sets the "wallet_address" field.
func (m *UsersMutation) SetWalletAddress(s string) {
	m.wallet_address = &s
}

// WalletAddress returns the value of the "wallet_address" field in the mutation.
func (m *UsersMutation) WalletAddress() (r string, exists bool) {
	v := m.wallet_address
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletAddress returns the old "wallet_address" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldWalletAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWalletAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWalletAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletAddress: %w", err)
	}
	return oldValue.WalletAddress, nil
}

// ResetWalletAddress resets all changes to the "wallet_address" field.
func (m *UsersMutation) ResetWalletAddress() {
	m.wallet_address = nil
}

// SetHasAccess sets the "has_access" field.
func (m *UsersMutation) SetHasAccess(b bool) {
	m.has_access = &b
}

// HasAccess returns the value of the "has_access" field in the mutation.
func (m *UsersMutation) HasAccess() (r bool, exists bool) {
	v := m.has_access
	if v == nil {
		return
	}
	return *v, true
}

// OldHasAccess returns the old "has_access" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldHasAccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasAccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasAccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasAccess: %w", err)
	}
	return oldValue.HasAccess, nil
}

// ResetHasAccess resets all changes to the "has_access" field.
func (m *UsersMutation) ResetHasAccess() {
	m.has_access = nil
}

// AddMatchIDs adds the "matches" edge to the Matches entity by ids.
func (m *UsersMutation) AddMatchIDs(ids ...int) {
	if m.matches == nil {
		m.matches = make(map[int]struct{})
	}
	for i := range ids {
		m.matches[ids[i]] = struct{}{}
	}
}

// ClearMatches clears the "matches" edge to the Matches entity.
func (m *UsersMutation) ClearMatches() {
	m.clearedmatches = true
}

// MatchesCleared reports if the "matches" edge to the Matches entity was cleared.
func (m *UsersMutation) MatchesCleared() bool {
	return m.clearedmatches
}

// RemoveMatchIDs removes the "matches" edge to the Matches entity by IDs.
func (m *UsersMutation) RemoveMatchIDs(ids ...int) {
	if m.removedmatches == nil {
		m.removedmatches = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.matches, ids[i])
		m.removedmatches[ids[i]] = struct{}{}
	}
}

// RemovedMatches returns the removed IDs of the "matches" edge to the Matches entity.
func (m *UsersMutation) RemovedMatchesIDs() (ids []int) {
	for id := range m.removedmatches {
		ids = append(ids, id)
	}
	return
}

// MatchesIDs returns the "matches" edge IDs in the mutation.
func (m *UsersMutation) MatchesIDs() (ids []int) {
	for id := range m.matches {
		ids = append(ids, id)
	}
	return
}

// ResetMatches resets all changes to the "matches" edge.
func (m *UsersMutation) ResetMatches() {
	m.matches = nil
	m.clearedmatches = false
	m.removedmatches = nil
}

// AddMatchResultIDs adds the "match_results" edge to the MatchResults entity by ids.
func (m *UsersMutation) AddMatchResultIDs(ids ...int) {
	if m.match_results == nil {
		m.match_results = make(map[int]struct{})
	}
	for i := range ids {
		m.match_results[ids[i]] = struct{}{}
	}
}

// ClearMatchResults clears the "match_results" edge to the MatchResults entity.
func (m *UsersMutation) ClearMatchResults() {
	m.clearedmatch_results = true
}

// MatchResultsCleared reports if the "match_results" edge to the MatchResults entity was cleared.
func (m *UsersMutation) MatchResultsCleared() bool {
	return m.clearedmatch_results
}

// RemoveMatchResultIDs removes the "match_results" edge to the MatchResults entity by IDs.
func (m *UsersMutation) RemoveMatchResultIDs(ids ...int) {
	if m.removedmatch_results == nil {
		m.removedmatch_results = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.match_results, ids[i])
		m.removedmatch_results[ids[i]] = struct{}{}
	}
}

// RemovedMatchResults returns the removed IDs of the "match_results" edge to the MatchResults entity.
func (m *UsersMutation) RemovedMatchResultsIDs() (ids []int) {
	for id := range m.removedmatch_results {
		ids = append(ids, id)
	}
	return
}

// MatchResultsIDs returns the "match_results" edge IDs in the mutation.
func (m *UsersMutation) MatchResultsIDs() (ids []int) {
	for id := range m.match_results {
		ids = append(ids, id)
	}
	return
}

// ResetMatchResults resets all changes to the "match_results" edge.
func (m *UsersMutation) ResetMatchResults() {
	m.match_results = nil
	m.clearedmatch_results = false
	m.removedmatch_results = nil
}

// AddPaymentIDs adds the "payments" edge to the PaymentVerifications entity by ids.
func (m *UsersMutation) AddPaymentIDs(ids ...int) {
	if m.payments == nil {
		m.payments = make(map[int]struct{})
	}
	for i := range ids {
		m.payments[ids[i]] = struct{}{}
	}
}

// ClearPayments clears the "payments" edge to the PaymentVerifications entity.
func (m *UsersMutation) ClearPayments() {
	m.clearedpayments = true
}

// PaymentsCleared reports if the "payments" edge to the PaymentVerifications entity was cleared.
func (m *UsersMutation) PaymentsCleared() bool {
	return m.clearedpayments
}

// RemovePaymentIDs removes the "payments" edge to the PaymentVerifications entity by IDs.
func (m *UsersMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayments == nil {
		m.removedpayments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.payments, ids[i])
		m.removedpayments[ids[i]] = struct{}{}
	}
}

// RemovedPayments returns the removed IDs of the "payments" edge to the PaymentVerifications entity.
func (m *UsersMutation) RemovedPaymentsIDs() (ids []int) {
	for id := range m.removedpayments {
		ids = append(ids, id)
	}
	return
}

// PaymentsIDs returns the "payments" edge IDs in the mutation.
func (m *UsersMutation) PaymentsIDs() (ids []int) {
	for id := range m.payments {
		ids = append(ids, id)
	}
	return
}

// ResetPayments resets all changes to the "payments" edge.
func (m *UsersMutation) ResetPayments() {
	m.payments = nil
	m.clearedpayments = false
	m.removedpayments = nil
}

// Where appends a list predicates to the UsersMutation builder.
func (m *UsersMutation) Where(ps ...predicate.Users) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Users, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Users).
func (m *UsersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsersMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.wallet_address != nil {
		fields = append(fields, users.FieldWalletAddress)
	}
	if m.has_access != nil {
		fields = append(fields, users.FieldHasAccess)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case users.FieldWalletAddress:
		return m.WalletAddress()
	case users.FieldHasAccess:
		return m.HasAccess()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case users.FieldWalletAddress:
		return m.OldWalletAddress(ctx)
	case users.FieldHasAccess:
		return m.OldHasAccess(ctx)
	}
	return nil, fmt.Errorf("unknown Users field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case users.FieldWalletAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletAddress(v)
		return nil
	case users.FieldHasAccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasAccess(v)
		return nil
	}
	return fmt.Errorf("unknown Users field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsersMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsersMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsersMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Users numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsersMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsersMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Users nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsersMutation) ResetField(name string) error {
	switch name {
	case users.FieldWalletAddress:
		m.ResetWalletAddress()
		return nil
	case users.FieldHasAccess:
		m.ResetHasAccess()
		return nil
	}
	return fmt.Errorf("unknown Users field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsersMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.matches != nil {
		edges = append(edges, users.EdgeMatches)
	}
	if m.match_results != nil {
		edges = append(edges, users.EdgeMatchResults)
	}
	if m.payments != nil {
		edges = append(edges, users.EdgePayments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsersMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case users.EdgeMatches:
		ids := make([]ent.Value, 0, len(m.matches))
		for id := range m.matches {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeMatchResults:
		ids := make([]ent.Value, 0, len(m.match_results))
		for id := range m.match_results {
			ids = append(ids, id)
		}
		return ids
	case users.EdgePayments:
		ids := make([]ent.Value, 0, len(m.payments))
		for id := range m.payments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmatches != nil {
		edges = append(edges, users.EdgeMatches)
	}
	if m.removedmatch_results != nil {
		edges = append(edges, users.EdgeMatchResults)
	}
	if m.removedpayments != nil {
		edges = append(edges, users.EdgePayments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsersMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case users.EdgeMatches:
		ids := make([]ent.Value, 0, len(m.removedmatches))
		for id := range m.removedmatches {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeMatchResults:
		ids := make([]ent.Value, 0, len(m.removedmatch_results))
		for id := range m.removedmatch_results {
			ids = append(ids, id)
		}
		return ids
	case users.EdgePayments:
		ids := make([]ent.Value, 0, len(m.removedpayments))
		for id := range m.removedpayments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmatches {
		edges = append(edges, users.EdgeMatches)
	}
	if m.clearedmatch_results {
		edges = append(edges, users.EdgeMatchResults)
	}
	if m.clearedpayments {
		edges = append(edges, users.EdgePayments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsersMutation) EdgeCleared(name string) bool {
	switch name {
	case users.EdgeMatches:
		return m.clearedmatches
	case users.EdgeMatchResults:
		return m.clearedmatch_results
	case users.EdgePayments:
		return m.clearedpayments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsersMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Users unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsersMutation) ResetEdge(name string) error {
	switch name {
	case users.EdgeMatches:
		m.ResetMatches()
		return nil
	case users.EdgeMatchResults:
		m.ResetMatchResults()
		return nil
	case users.EdgePayments:
		m.ResetPayments()
		return nil
	}
	return fmt.Errorf("unknown Users edge %s", name)
}
